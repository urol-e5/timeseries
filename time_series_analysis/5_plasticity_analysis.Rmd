---
title: "Plasticity analysis of E5 time series biological data"
author: "Ariana S Huffmyer, E5 RoL Team"
date: "08/22/2022"
output: 
  html_document:
    code_folding: hide
    toc: yes
    toc_depth: 6
    toc_float: yes
editor_options: 
  chunk_output_type: console
--- 

# Set Up     

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
```

```{r}
## install packages if you dont already have them
if (!require("tidyverse")) install.packages("tidyverse")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("RColorBrewer")) install.packages("RColorBrewer")
if (!require("lme4")) install.packages("lme4")
if (!require("lmerTest")) install.packages("lmerTest")
if (!require("car")) install.packages("car")
if (!require("effects")) install.packages("effects")
if (!require("ggfortify")) install.packages("ggfortify")
if (!require("cowplot")) install.packages("cowplot")
if (!require("vegan")) install.packages("vegan")
if (!require("corrr")) install.packages("corrr")
if (!require("ggcorrplot")) install.packages("ggcorrplot")
if (!require("GGally")) install.packages("GGally")
if (!require("broom")) install.packages("broom")
if (!require("cowplot")) install.packages("cowplot")

# load packages
library(tidyverse)
library(ggplot2)
library(RColorBrewer)
library(lme4)
library(lmerTest)
library(car)
library(effects)
library(ggfortify)
library(cowplot)
library(vegan)
library(corrr)
library(ggcorrplot)
library(GGally)
library(broom)
library(cowplot)
```

# Load dataframe  

Load in master dataframe generated from 1_assemble_data.Rmd.  
```{r}
master<-read.csv("Output/master_timeseries.csv")

#reorder site levels 
master$side_code<-as.factor(master$site_code)
master$site_code<-fct_relevel(master$site_code, "Mahana Low", "Hilton Medium", "Manava High")
```

# Population - level analysis  

Calculate the plasticity of physiological profiles (ratio of distance between centroids to the average spread of points in the PCA) at the population level produced in 4_multivariate_analysis.Rmd).  

## All responses 

### Acropora 

Generate PCA using scaled (scaled_acr_afdw) from dataframe (acr_data_afdw).   
 
```{r}
acr_data_afdw<-master%>%
  select(colony_id_corr, timepoint, species, site_code, Host_AFDW.mg.cm2, Sym_AFDW.mg.cm2, Ratio_AFDW.mg.cm2, Total_Chl, Total_Chl_cell, prot_mg.mgafdw, cells.mgAFDW, cre.umol.mgafdw, Am, AQY, Rd, calc.umol.mgAFDW.hr)%>%
  filter(Host_AFDW.mg.cm2>0)%>%
  filter(Sym_AFDW.mg.cm2>0)%>%
  filter(Ratio_AFDW.mg.cm2>0)%>%
  filter(species=="Acropora")%>%
  filter(Sym_AFDW.mg.cm2<20)%>%
  filter(prot_mg.mgafdw<1.5)%>% #remove outliers
  rename(Host_Biomass=Host_AFDW.mg.cm2, Symbiont_Biomass=Sym_AFDW.mg.cm2, S_H_Biomass_Ratio=Ratio_AFDW.mg.cm2, Host_Protein=prot_mg.mgafdw, Symbiont_Density=cells.mgAFDW, Antiox_Capacity=cre.umol.mgafdw, Calc=calc.umol.mgAFDW.hr)

acr_data_afdw<-acr_data_afdw[complete.cases(acr_data_afdw), ]

scaled_acr_afdw<-prcomp(acr_data_afdw[c(5:16)], scale=TRUE, center=TRUE) 

acr_info<-acr_data_afdw[c(2,4)]

acr_data<-scaled_acr_afdw%>%
  augment(acr_info)%>%
  group_by(timepoint, site_code)%>%
  mutate(PC1.mean = mean(.fittedPC1),
         PC2.mean = mean(.fittedPC2))

acr.centroids<-acr_data %>% 
  select(timepoint, site_code, PC1.mean, PC2.mean)%>%
  group_by(timepoint, site_code)%>%
  summarise(PC1.mean = mean(PC1.mean),
         PC2.mean = mean(PC2.mean))
```

1 - calculate sd of mean distance between all points and the centroid of all points (spread)

```{r}

#calculate mean centroid location
mean.centroid.acr <- acr.centroids%>%
  select(PC1.mean, PC2.mean)%>%
  summarise(x.mean = mean(PC1.mean), 
         y.mean = mean(PC2.mean))%>%
  summarise(x.mean = mean(x.mean), 
         y.mean = mean(y.mean))

#calculate average standard deviation of mean distance between mean centroid and location of each point using formula for distance between two points
spread.acr<-acr_data%>%
  mutate(distance=sqrt((PC1.mean-mean.centroid.acr[1])^2+(PC2.mean-mean.centroid.acr[2])^2))%>%
  summarise(distance=mean(distance$x.mean))%>% #summarize across groups
  summarise(distance=sd(distance))%>% #calculate the sd of distances
  summarise(distance=mean(distance)) #summarize across groups

spread.acr$distance
```

2 - calculate distance between each time point centroids for each site (distance) 

```{r}
distance.acr<-acr.centroids%>%
  arrange(site_code)%>%
  gather(variable, value, -(timepoint:site_code)) %>%
  unite(temp, timepoint, variable) %>%
  spread(temp, value)%>%
  group_by(site_code)%>%
  mutate(tp1.2=sqrt((timepoint1_PC1.mean-timepoint2_PC1.mean)^2+(timepoint1_PC2.mean-timepoint2_PC2.mean)^2), #calculate distance between tp1 and tp2 centroids, do for each pair of time points
         tp2.3=sqrt((timepoint2_PC1.mean-timepoint3_PC1.mean)^2+(timepoint2_PC2.mean-timepoint3_PC2.mean)^2),
         tp3.4=sqrt((timepoint3_PC1.mean-timepoint4_PC1.mean)^2+(timepoint3_PC2.mean-timepoint4_PC2.mean)^2))
```

3 - divide distance by spread, generating a plasticity ratio for each site, higher ratio = more plasticity

```{r}
plasticity.acr.all<-distance.acr%>%
  select(site_code, tp1.2, tp2.3, tp3.4)%>% #keep desired columns
  gather(key="comparison", value="distance_time", -site_code)%>% #gather and generate new rows to designate time comparisons
  mutate(ratio=distance_time/spread.acr$distance)%>%
  mutate(fraction="All Responses")%>%
  mutate(species="Acropora")
plasticity.acr.all
```

### Porites  

```{r}
por_data_afdw<-master%>%
  select(colony_id_corr, timepoint, species, site_code, Host_AFDW.mg.cm2, Sym_AFDW.mg.cm2, Ratio_AFDW.mg.cm2, Total_Chl, Total_Chl_cell, prot_mg.mgafdw, cells.mgAFDW, cre.umol.mgafdw, Am, AQY, Rd, calc.umol.mgAFDW.hr)%>%
  filter(Host_AFDW.mg.cm2>0)%>%
  filter(Sym_AFDW.mg.cm2>0)%>%
  filter(Ratio_AFDW.mg.cm2>0)%>%
  filter(species=="Porites")%>%
  filter(Sym_AFDW.mg.cm2<20)%>%
  filter(prot_mg.mgafdw<1.5)%>% #remove outliers
  rename(Host_Biomass=Host_AFDW.mg.cm2, Symbiont_Biomass=Sym_AFDW.mg.cm2, S_H_Biomass_Ratio=Ratio_AFDW.mg.cm2, Host_Protein=prot_mg.mgafdw, Symbiont_Density=cells.mgAFDW, Antiox_Capacity=cre.umol.mgafdw, Calc=calc.umol.mgAFDW.hr)

por_data_afdw<-por_data_afdw[complete.cases(por_data_afdw), ]

scaled_por_afdw<-prcomp(por_data_afdw[c(5:16)], scale=TRUE, center=TRUE) 

por_info<-por_data_afdw[c(2,4)]

por_data<-scaled_por_afdw%>%
  augment(por_info)%>%
  group_by(timepoint, site_code)%>%
  mutate(PC1.mean = mean(.fittedPC1),
         PC2.mean = mean(.fittedPC2))

por.centroids<-por_data %>% 
  select(timepoint, site_code, PC1.mean, PC2.mean)%>%
  group_by(timepoint, site_code)%>%
  summarise(PC1.mean = mean(PC1.mean),
         PC2.mean = mean(PC2.mean))
```

1 - calculate mean distance between all points and the centroid of all points (spread)   

```{r}
#calculate mean centroid location
mean.centroid.por <- por.centroids%>%
  select(PC1.mean, PC2.mean)%>%
  summarise(x.mean = mean(PC1.mean), 
         y.mean = mean(PC2.mean))%>%
  summarise(x.mean = mean(x.mean), 
         y.mean = mean(y.mean))

#calculate average standard deviation of mean distance between mean centroid and location of each point using formula for distance between two points
spread.por<-por_data%>%
  mutate(distance=sqrt((PC1.mean-mean.centroid.por[1])^2+(PC2.mean-mean.centroid.por[2])^2))%>%
  summarise(distance=mean(distance$x.mean))%>% #summarize across groups
  summarise(distance=sd(distance))%>% #summarize across groups
  summarise(distance=mean(distance)) #summarize across groups

#spread<-acr_data[c(12,13)]
#spread<-as.matrix(dist(spread, mean.centroid, method="euclidean"))
#spread<-mean(spread)
spread.por
```

2 - calculate distance between each time point centroids for each site (distance) 

```{r}
distance.por<-por.centroids%>%
  arrange(site_code)%>%
  gather(variable, value, -(timepoint:site_code)) %>%
  unite(temp, timepoint, variable) %>%
  spread(temp, value)%>%
  group_by(site_code)%>%
  mutate(tp1.2=sqrt((timepoint1_PC1.mean-timepoint2_PC1.mean)^2+(timepoint1_PC2.mean-timepoint2_PC2.mean)^2), #calculate distance between tp1 and tp2 centroids, do for each pair of time points
         tp2.3=sqrt((timepoint2_PC1.mean-timepoint3_PC1.mean)^2+(timepoint2_PC2.mean-timepoint3_PC2.mean)^2),
         tp3.4=sqrt((timepoint3_PC1.mean-timepoint4_PC1.mean)^2+(timepoint3_PC2.mean-timepoint4_PC2.mean)^2))
```

3 - divide distance by spread, generating a plasticity ratio for each site, higher ratio = more plasticity

```{r}
plasticity.por.all<-distance.por%>%
  select(site_code, tp1.2, tp2.3, tp3.4)%>% #keep desired columns
  gather(key="comparison", value="distance_time", -site_code)%>% #gather and generate new rows to designate time comparisons
  mutate(ratio=distance_time/spread.por$distance)%>%
  mutate(fraction="All Responses")%>%
  mutate(species="Porites")
plasticity.por.all
```

### Pocillopora  

```{r}
poc_data_afdw<-master%>%
  select(colony_id_corr, timepoint, species, site_code, Host_AFDW.mg.cm2, Sym_AFDW.mg.cm2, Ratio_AFDW.mg.cm2, Total_Chl, Total_Chl_cell, prot_mg.mgafdw, cells.mgAFDW, cre.umol.mgafdw, Am, AQY, Rd, calc.umol.mgAFDW.hr)%>%
  filter(Host_AFDW.mg.cm2>0)%>%
  filter(Sym_AFDW.mg.cm2>0)%>%
  filter(Ratio_AFDW.mg.cm2>0)%>%
  filter(species=="Pocillopora")%>%
  filter(Sym_AFDW.mg.cm2<20)%>%
  rename(Host_Biomass=Host_AFDW.mg.cm2, Symbiont_Biomass=Sym_AFDW.mg.cm2, S_H_Biomass_Ratio=Ratio_AFDW.mg.cm2, Host_Protein=prot_mg.mgafdw, Symbiont_Density=cells.mgAFDW, Antiox_Capacity=cre.umol.mgafdw, Calc=calc.umol.mgAFDW.hr)

poc_data_afdw<-poc_data_afdw[complete.cases(poc_data_afdw), ]
 
scaled_poc_afdw<-prcomp(poc_data_afdw[c(5:16)], scale=TRUE, center=TRUE) 

poc_info<-poc_data_afdw[c(2,4)]

poc_data<-scaled_poc_afdw%>%
  augment(poc_info)%>%
  group_by(timepoint, site_code)%>%
  mutate(PC1.mean = mean(.fittedPC1),
         PC2.mean = mean(.fittedPC2))

poc.centroids<-poc_data %>% 
  select(timepoint, site_code, PC1.mean, PC2.mean)%>%
  group_by(timepoint, site_code)%>%
  summarise(PC1.mean = mean(PC1.mean),
         PC2.mean = mean(PC2.mean))
``` 

1 - calculate mean distance between all points and the centroid of all points (spread)

```{r}
#calculate mean centroid location
mean.centroid.poc <- poc.centroids%>%
  select(PC1.mean, PC2.mean)%>%
  summarise(x.mean = mean(PC1.mean), 
         y.mean = mean(PC2.mean))%>%
  summarise(x.mean = mean(x.mean), 
         y.mean = mean(y.mean))

#calculate average distance between mean centroid and location of each point using formula for distance between two points
spread.poc<-poc_data%>%
  mutate(distance=sqrt((PC1.mean-mean.centroid.poc[1])^2+(PC2.mean-mean.centroid.poc[2])^2))%>%
  summarise(distance=mean(distance$x.mean))%>% #summarize across groups
  summarise(distance=sd(distance))%>% #summarize across groups
  summarise(distance=mean(distance)) #summarize across groups

#spread<-acr_data[c(12,13)]
#spread<-as.matrix(dist(spread, mean.centroid, method="euclidean"))
#spread<-mean(spread)
spread.poc
```

2 - calculate distance between each time point centroids for each site (distance) 

```{r}
distance.poc<-poc.centroids%>%
  arrange(site_code)%>%
  gather(variable, value, -(timepoint:site_code)) %>%
  unite(temp, timepoint, variable) %>%
  spread(temp, value)%>%
  group_by(site_code)%>%
  mutate(tp1.2=sqrt((timepoint1_PC1.mean-timepoint2_PC1.mean)^2+(timepoint1_PC2.mean-timepoint2_PC2.mean)^2), #calculate distance between tp1 and tp2 centroids, do for each pair of time points
         tp2.3=sqrt((timepoint2_PC1.mean-timepoint3_PC1.mean)^2+(timepoint2_PC2.mean-timepoint3_PC2.mean)^2),
         tp3.4=sqrt((timepoint3_PC1.mean-timepoint4_PC1.mean)^2+(timepoint3_PC2.mean-timepoint4_PC2.mean)^2))
```

3 - divide distance by spread, generating a plasticity ratio for each site, higher ratio = more plasticity

```{r}
plasticity.poc.all<-distance.poc%>%
  select(site_code, tp1.2, tp2.3, tp3.4)%>% #keep desired columns
  gather(key="comparison", value="distance_time", -site_code)%>% #gather and generate new rows to designate time comparisons
  mutate(ratio=distance_time/spread.poc$distance)%>%
  mutate(fraction="All Responses")%>%
  mutate(species="Pocillopora")
plasticity.poc.all
```


 
 
## Holobiont Responses  

Generate a list of symbiont and host responses.  
```{r}
symbiont_responses<-c("cells.mgAFDW", "Sym_AFDW.mg.cm2", "Total_Chl", "Total_Chl_cell", "Am", "AQY", "Ratio_AFDW.mg.cm2") 
holobiont_responses<-c("cre.umol.mgafdw", "Host_AFDW.mg.cm2", "prot_mg.mgafdw", "Rd", "calc.umol.mgAFDW.hr")
```

### Acropora 

```{r}
acr_data_afdw<-master%>%
  select(colony_id_corr, timepoint, species, site_code, all_of(holobiont_responses))%>%
  filter(Host_AFDW.mg.cm2>0)%>%
  #filter(Sym_AFDW.mg.cm2>0)%>%
  #filter(Ratio_AFDW.mg.cm2>0)%>%
  filter(species=="Acropora")%>%
  #filter(Sym_AFDW.mg.cm2<20)%>%
  filter(prot_mg.mgafdw<1.5) %>% #remove outliers
  rename(Host_Biomass=Host_AFDW.mg.cm2, Host_Protein=prot_mg.mgafdw, Antiox_Capacity=cre.umol.mgafdw, Respiration=Rd, Calc=calc.umol.mgAFDW.hr)

acr_data_afdw<-acr_data_afdw[complete.cases(acr_data_afdw), ]

scaled_acr_afdw<-prcomp(acr_data_afdw[c(5:9)], scale=TRUE, center=TRUE) 

acr_info<-acr_data_afdw[c(2,4)]

acr_data<-scaled_acr_afdw%>%
  augment(acr_info)%>%
  group_by(timepoint, site_code)%>%
  mutate(PC1.mean = mean(.fittedPC1),
         PC2.mean = mean(.fittedPC2))

acr.centroids<-acr_data %>% 
  select(timepoint, site_code, PC1.mean, PC2.mean)%>%
  group_by(timepoint, site_code)%>%
  summarise(PC1.mean = mean(PC1.mean),
         PC2.mean = mean(PC2.mean))
```

1 - calculate sd of mean distance between all points and the centroid of all points (spread)

```{r}
#calculate mean centroid location
mean.centroid.acr <- acr.centroids%>%
  select(PC1.mean, PC2.mean)%>%
  summarise(x.mean = mean(PC1.mean), 
         y.mean = mean(PC2.mean))%>%
  summarise(x.mean = mean(x.mean), 
         y.mean = mean(y.mean))

#calculate average standard deviation of mean distance between mean centroid and location of each point using formula for distance between two points
spread.acr<-acr_data%>%
  mutate(distance=sqrt((PC1.mean-mean.centroid.acr[1])^2+(PC2.mean-mean.centroid.acr[2])^2))%>%
  summarise(distance=mean(distance$x.mean))%>% #summarize across groups
  summarise(distance=sd(distance))%>% #calculate the sd of distances
  summarise(distance=mean(distance)) #summarize across groups

spread.acr$distance
```

2 - calculate distance between each time point centroids for each site (distance) 

```{r}
distance.acr<-acr.centroids%>%
  arrange(site_code)%>%
  gather(variable, value, -(timepoint:site_code)) %>%
  unite(temp, timepoint, variable) %>%
  spread(temp, value)%>%
  group_by(site_code)%>%
  mutate(tp1.2=sqrt((timepoint1_PC1.mean-timepoint2_PC1.mean)^2+(timepoint1_PC2.mean-timepoint2_PC2.mean)^2), #calculate distance between tp1 and tp2 centroids, do for each pair of time points
         tp2.3=sqrt((timepoint2_PC1.mean-timepoint3_PC1.mean)^2+(timepoint2_PC2.mean-timepoint3_PC2.mean)^2),
         tp3.4=sqrt((timepoint3_PC1.mean-timepoint4_PC1.mean)^2+(timepoint3_PC2.mean-timepoint4_PC2.mean)^2))
```

3 - divide distance by spread, generating a plasticity ratio for each site, higher ratio = more plasticity

```{r}
plasticity.acr.holo<-distance.acr%>%
  select(site_code, tp1.2, tp2.3, tp3.4)%>% #keep desired columns
  gather(key="comparison", value="distance_time", -site_code)%>% #gather and generate new rows to designate time comparisons
  mutate(ratio=distance_time/spread.acr$distance)%>%
  mutate(species="Acropora")%>%
  mutate(fraction="Holobiont")
plasticity.acr.holo
```

### Porites 

```{r}
por_data_afdw<-master%>%
  select(colony_id_corr, timepoint, species, site_code, all_of(holobiont_responses))%>%
  filter(Host_AFDW.mg.cm2>0)%>%
  #filter(Sym_AFDW.mg.cm2>0)%>%
  #filter(Ratio_AFDW.mg.cm2>0)%>%
  #filter(Sym_AFDW.mg.cm2<20)%>%
  filter(species=="Porites")%>%
  filter(prot_mg.mgafdw<1.5)%>% #remove outliers
  rename(Host_Biomass=Host_AFDW.mg.cm2, Respiration=Rd, Host_Protein=prot_mg.mgafdw, Antiox_Capacity=cre.umol.mgafdw, Calc=calc.umol.mgAFDW.hr)

por_data_afdw<-por_data_afdw[complete.cases(por_data_afdw), ]

scaled_por_afdw<-prcomp(por_data_afdw[c(5:9)], scale=TRUE, center=TRUE) 

por_info<-por_data_afdw[c(2,4)]

por_data<-scaled_por_afdw%>%
  augment(por_info)%>%
  group_by(timepoint, site_code)%>%
  mutate(PC1.mean = mean(.fittedPC1),
         PC2.mean = mean(.fittedPC2))

por.centroids<-por_data %>% 
  select(timepoint, site_code, PC1.mean, PC2.mean)%>%
  group_by(timepoint, site_code)%>%
  summarise(PC1.mean = mean(PC1.mean),
         PC2.mean = mean(PC2.mean))
```

1 - calculate mean distance between all points and the centroid of all points (spread)   

```{r}
#calculate mean centroid location
mean.centroid.por <- por.centroids%>%
  select(PC1.mean, PC2.mean)%>%
  summarise(x.mean = mean(PC1.mean), 
         y.mean = mean(PC2.mean))%>%
  summarise(x.mean = mean(x.mean), 
         y.mean = mean(y.mean))

#calculate average standard deviation of mean distance between mean centroid and location of each point using formula for distance between two points
spread.por<-por_data%>%
  mutate(distance=sqrt((PC1.mean-mean.centroid.por[1])^2+(PC2.mean-mean.centroid.por[2])^2))%>%
  summarise(distance=mean(distance$x.mean))%>% #summarize across groups
  summarise(distance=sd(distance))%>% #summarize across groups
  summarise(distance=mean(distance)) #summarize across groups

#spread<-acr_data[c(12,13)]
#spread<-as.matrix(dist(spread, mean.centroid, method="euclidean"))
#spread<-mean(spread)
spread.por
```

2 - calculate distance between each time point centroids for each site (distance) 

```{r}
distance.por<-por.centroids%>%
  arrange(site_code)%>%
  gather(variable, value, -(timepoint:site_code)) %>%
  unite(temp, timepoint, variable) %>%
  spread(temp, value)%>%
  group_by(site_code)%>%
  mutate(tp1.2=sqrt((timepoint1_PC1.mean-timepoint2_PC1.mean)^2+(timepoint1_PC2.mean-timepoint2_PC2.mean)^2), #calculate distance between tp1 and tp2 centroids, do for each pair of time points
         tp2.3=sqrt((timepoint2_PC1.mean-timepoint3_PC1.mean)^2+(timepoint2_PC2.mean-timepoint3_PC2.mean)^2),
         tp3.4=sqrt((timepoint3_PC1.mean-timepoint4_PC1.mean)^2+(timepoint3_PC2.mean-timepoint4_PC2.mean)^2))
```

3 - divide distance by spread, generating a plasticity ratio for each site, higher ratio = more plasticity

```{r}
plasticity.por.holo<-distance.por%>%
  select(site_code, tp1.2, tp2.3, tp3.4)%>% #keep desired columns
  gather(key="comparison", value="distance_time", -site_code)%>% #gather and generate new rows to designate time comparisons
  mutate(ratio=distance_time/spread.por$distance)%>%
  mutate(fraction="Holobiont")%>%
  mutate(species="Porites")
plasticity.por.holo
```

### Pocillopora 

```{r}
poc_data_afdw<-master%>%
  select(colony_id_corr, timepoint, species, site_code, all_of(holobiont_responses))%>%
  filter(Host_AFDW.mg.cm2>0)%>%
  #filter(Sym_AFDW.mg.cm2>0)%>%
  #filter(Sym_AFDW.mg.cm2<20)%>%
  #filter(Ratio_AFDW.mg.cm2>0)%>%
  filter(species=="Pocillopora")%>%
  rename(Host_Biomass=Host_AFDW.mg.cm2, Respiration=Rd, Host_Protein=prot_mg.mgafdw, Antiox_Capacity=cre.umol.mgafdw, Calc=calc.umol.mgAFDW.hr)

poc_data_afdw<-poc_data_afdw[complete.cases(poc_data_afdw), ]
 
scaled_poc_afdw<-prcomp(poc_data_afdw[c(5:9)], scale=TRUE, center=TRUE) 

poc_info<-poc_data_afdw[c(2,4)]

poc_data<-scaled_poc_afdw%>%
  augment(poc_info)%>%
  group_by(timepoint, site_code)%>%
  mutate(PC1.mean = mean(.fittedPC1),
         PC2.mean = mean(.fittedPC2))

poc.centroids<-poc_data %>% 
  select(timepoint, site_code, PC1.mean, PC2.mean)%>%
  group_by(timepoint, site_code)%>%
  summarise(PC1.mean = mean(PC1.mean),
         PC2.mean = mean(PC2.mean))
``` 

1 - calculate mean distance between all points and the centroid of all points (spread)

```{r}
#calculate mean centroid location
mean.centroid.poc <- poc.centroids%>%
  select(PC1.mean, PC2.mean)%>%
  summarise(x.mean = mean(PC1.mean), 
         y.mean = mean(PC2.mean))%>%
  summarise(x.mean = mean(x.mean), 
         y.mean = mean(y.mean))

#calculate average distance between mean centroid and location of each point using formula for distance between two points
spread.poc<-poc_data%>%
  mutate(distance=sqrt((PC1.mean-mean.centroid.poc[1])^2+(PC2.mean-mean.centroid.poc[2])^2))%>%
  summarise(distance=mean(distance$x.mean))%>% #summarize across groups
  summarise(distance=sd(distance))%>% #summarize across groups
  summarise(distance=mean(distance)) #summarize across groups

spread.poc
```

 
2 - calculate distance between each time point centroids for each site (distance) 

```{r}
distance.poc<-poc.centroids%>%
  arrange(site_code)%>%
  gather(variable, value, -(timepoint:site_code)) %>%
  unite(temp, timepoint, variable) %>%
  spread(temp, value)%>%
  group_by(site_code)%>%
  mutate(tp1.2=sqrt((timepoint1_PC1.mean-timepoint2_PC1.mean)^2+(timepoint1_PC2.mean-timepoint2_PC2.mean)^2), #calculate distance between tp1 and tp2 centroids, do for each pair of time points
         tp2.3=sqrt((timepoint2_PC1.mean-timepoint3_PC1.mean)^2+(timepoint2_PC2.mean-timepoint3_PC2.mean)^2),
         tp3.4=sqrt((timepoint3_PC1.mean-timepoint4_PC1.mean)^2+(timepoint3_PC2.mean-timepoint4_PC2.mean)^2))
```

3 - divide distance by spread, generating a plasticity ratio for each site, higher ratio = more plasticity

```{r}
plasticity.poc.holo<-distance.poc%>%
  select(site_code, tp1.2, tp2.3, tp3.4)%>% #keep desired columns
  gather(key="comparison", value="distance_time", -site_code)%>% #gather and generate new rows to designate time comparisons
  mutate(ratio=distance_time/spread.poc$distance)%>%
  mutate(fraction="Holobiont")%>%
  mutate(species="Pocillopora")
plasticity.poc.holo
```

## Symbiont Responses  

### Acropora  

```{r}
acr_data_afdw<-master%>%
  select(colony_id_corr, timepoint, species, site_code, all_of(symbiont_responses))%>%
  #filter(Host_AFDW.mg.cm2>0)%>%
  filter(Sym_AFDW.mg.cm2>0)%>%
  #filter(Ratio_AFDW.mg.cm2>0)%>%
  #filter(Total_Chl<13)%>%
  filter(Sym_AFDW.mg.cm2<20)%>%
  filter(species=="Acropora")%>%
  #filter(prot_mg.mgafdw<1.5)%>% #remove outliers
  rename(Symbiont_Biomass=Sym_AFDW.mg.cm2, Symbiont_Density=cells.mgAFDW, Total_Chl=Total_Chl, Total_Chl_Cell=Total_Chl_cell, SH_Ratio=Ratio_AFDW.mg.cm2)

acr_data_afdw<-acr_data_afdw[complete.cases(acr_data_afdw), ]

scaled_acr_afdw<-prcomp(acr_data_afdw[c(5:11)], scale=TRUE, center=TRUE) 

acr_info<-acr_data_afdw[c(2,4)]

acr_data<-scaled_acr_afdw%>%
  augment(acr_info)%>%
  group_by(timepoint, site_code)%>%
  mutate(PC1.mean = mean(.fittedPC1),
         PC2.mean = mean(.fittedPC2))

acr.centroids<-acr_data %>% 
  select(timepoint, site_code, PC1.mean, PC2.mean)%>%
  group_by(timepoint, site_code)%>%
  summarise(PC1.mean = mean(PC1.mean),
         PC2.mean = mean(PC2.mean))
```

1 - calculate sd of mean distance between all points and the centroid of all points (spread)

```{r}
#calculate mean centroid location
mean.centroid.acr <- acr.centroids%>%
  select(PC1.mean, PC2.mean)%>%
  summarise(x.mean = mean(PC1.mean), 
         y.mean = mean(PC2.mean))%>%
  summarise(x.mean = mean(x.mean), 
         y.mean = mean(y.mean))

#calculate average standard deviation of mean distance between mean centroid and location of each point using formula for distance between two points
spread.acr<-acr_data%>%
  mutate(distance=sqrt((PC1.mean-mean.centroid.acr[1])^2+(PC2.mean-mean.centroid.acr[2])^2))%>%
  summarise(distance=mean(distance$x.mean))%>% #summarize across groups
  summarise(distance=sd(distance))%>% #calculate the sd of distances
  summarise(distance=mean(distance)) #summarize across groups

spread.acr$distance
```

2 - calculate distance between each time point centroids for each site (distance) 

```{r}
distance.acr<-acr.centroids%>%
  arrange(site_code)%>%
  gather(variable, value, -(timepoint:site_code)) %>%
  unite(temp, timepoint, variable) %>%
  spread(temp, value)%>%
  group_by(site_code)%>%
  mutate(tp1.2=sqrt((timepoint1_PC1.mean-timepoint2_PC1.mean)^2+(timepoint1_PC2.mean-timepoint2_PC2.mean)^2), #calculate distance between tp1 and tp2 centroids, do for each pair of time points
         tp2.3=sqrt((timepoint2_PC1.mean-timepoint3_PC1.mean)^2+(timepoint2_PC2.mean-timepoint3_PC2.mean)^2),
         tp3.4=sqrt((timepoint3_PC1.mean-timepoint4_PC1.mean)^2+(timepoint3_PC2.mean-timepoint4_PC2.mean)^2))
```

3 - divide distance by spread, generating a plasticity ratio for each site, higher ratio = more plasticity

```{r}
plasticity.acr.sym<-distance.acr%>%
  select(site_code, tp1.2, tp2.3, tp3.4)%>% #keep desired columns
  gather(key="comparison", value="distance_time", -site_code)%>% #gather and generate new rows to designate time comparisons
  mutate(ratio=distance_time/spread.acr$distance)%>%
  mutate(fraction="Symbiont")%>%
  mutate(species="Acropora")
plasticity.acr.sym
```

### Porites

```{r}
por_data_afdw<-master%>%
  select(colony_id_corr, timepoint, species, site_code, all_of(symbiont_responses))%>%
  #filter(Host_AFDW.mg.cm2>0)%>%
  filter(Sym_AFDW.mg.cm2>0)%>%
  #filter(Ratio_AFDW.mg.cm2>0)%>%
  #filter(Total_Chl<13)%>%
  filter(Sym_AFDW.mg.cm2<20)%>%
  filter(species=="Porites")%>%
  #filter(prot_mg.mgafdw<1.5)%>% #remove outliers
  rename(Symbiont_Biomass=Sym_AFDW.mg.cm2, Symbiont_Density=cells.mgAFDW, Total_Chl=Total_Chl, Total_Chl_Cell=Total_Chl_cell, SH_Ratio=Ratio_AFDW.mg.cm2)

por_data_afdw<-por_data_afdw[complete.cases(por_data_afdw), ]

scaled_por_afdw<-prcomp(por_data_afdw[c(5:11)], scale=TRUE, center=TRUE) 

por_info<-por_data_afdw[c(2,4)]

por_data<-scaled_por_afdw%>%
  augment(por_info)%>%
  group_by(timepoint, site_code)%>%
  mutate(PC1.mean = mean(.fittedPC1),
         PC2.mean = mean(.fittedPC2))

por.centroids<-por_data %>% 
  select(timepoint, site_code, PC1.mean, PC2.mean)%>%
  group_by(timepoint, site_code)%>%
  summarise(PC1.mean = mean(PC1.mean),
         PC2.mean = mean(PC2.mean))
```

1 - calculate mean distance between all points and the centroid of all points (spread)   

```{r}
#calculate mean centroid location
mean.centroid.por <- por.centroids%>%
  select(PC1.mean, PC2.mean)%>%
  summarise(x.mean = mean(PC1.mean), 
         y.mean = mean(PC2.mean))%>%
  summarise(x.mean = mean(x.mean), 
         y.mean = mean(y.mean))

#calculate average standard deviation of mean distance between mean centroid and location of each point using formula for distance between two points
spread.por<-por_data%>%
  mutate(distance=sqrt((PC1.mean-mean.centroid.por[1])^2+(PC2.mean-mean.centroid.por[2])^2))%>%
  summarise(distance=mean(distance$x.mean))%>% #summarize across groups
  summarise(distance=sd(distance))%>% #summarize across groups
  summarise(distance=mean(distance)) #summarize across groups

spread.por
```

2 - calculate distance between each time point centroids for each site (distance) 

```{r}
distance.por<-por.centroids%>%
  arrange(site_code)%>%
  gather(variable, value, -(timepoint:site_code)) %>%
  unite(temp, timepoint, variable) %>%
  spread(temp, value)%>%
  group_by(site_code)%>%
  mutate(tp1.2=sqrt((timepoint1_PC1.mean-timepoint2_PC1.mean)^2+(timepoint1_PC2.mean-timepoint2_PC2.mean)^2), #calculate distance between tp1 and tp2 centroids, do for each pair of time points
         tp2.3=sqrt((timepoint2_PC1.mean-timepoint3_PC1.mean)^2+(timepoint2_PC2.mean-timepoint3_PC2.mean)^2),
         tp3.4=sqrt((timepoint3_PC1.mean-timepoint4_PC1.mean)^2+(timepoint3_PC2.mean-timepoint4_PC2.mean)^2))
```

3 - divide distance by spread, generating a plasticity ratio for each site, higher ratio = more plasticity

```{r}
plasticity.por.sym<-distance.por%>%
  select(site_code, tp1.2, tp2.3, tp3.4)%>% #keep desired columns
  gather(key="comparison", value="distance_time", -site_code)%>% #gather and generate new rows to designate time comparisons
  mutate(ratio=distance_time/spread.por$distance)%>%
  mutate(fraction="Symbiont")%>%
  mutate(species="Porites")
plasticity.por.sym
```

### Pocillopora 

```{r}
poc_data_afdw<-master%>%
  select(colony_id_corr, timepoint, species, site_code, all_of(symbiont_responses))%>%
  #filter(Host_AFDW.mg.cm2>0)%>%
  filter(Sym_AFDW.mg.cm2>0)%>%
  filter(Sym_AFDW.mg.cm2<20)%>%
  #filter(Ratio_AFDW.mg.cm2>0)%>%
  #filter(Total_Chl<13)%>%
  filter(species=="Pocillopora")%>%
  #filter(prot_mg.mgafdw<1.5)%>% #remove outliers
  rename(Symbiont_Biomass=Sym_AFDW.mg.cm2, Symbiont_Density=cells.mgAFDW, Total_Chl=Total_Chl, Total_Chl_Cell=Total_Chl_cell, SH_Ratio=Ratio_AFDW.mg.cm2)

poc_data_afdw<-poc_data_afdw[complete.cases(poc_data_afdw), ]
 
scaled_poc_afdw<-prcomp(poc_data_afdw[c(5:11)], scale=TRUE, center=TRUE) 

poc_info<-poc_data_afdw[c(2,4)]

poc_data<-scaled_poc_afdw%>%
  augment(poc_info)%>%
  group_by(timepoint, site_code)%>%
  mutate(PC1.mean = mean(.fittedPC1),
         PC2.mean = mean(.fittedPC2))

poc.centroids<-poc_data %>% 
  select(timepoint, site_code, PC1.mean, PC2.mean)%>%
  group_by(timepoint, site_code)%>%
  summarise(PC1.mean = mean(PC1.mean),
         PC2.mean = mean(PC2.mean))
``` 

1 - calculate mean distance between all points and the centroid of all points (spread)

```{r}
#calculate mean centroid location
mean.centroid.poc <- poc.centroids%>%
  select(PC1.mean, PC2.mean)%>%
  summarise(x.mean = mean(PC1.mean), 
         y.mean = mean(PC2.mean))%>%
  summarise(x.mean = mean(x.mean), 
         y.mean = mean(y.mean))

#calculate average distance between mean centroid and location of each point using formula for distance between two points
spread.poc<-poc_data%>%
  mutate(distance=sqrt((PC1.mean-mean.centroid.poc[1])^2+(PC2.mean-mean.centroid.poc[2])^2))%>%
  summarise(distance=mean(distance$x.mean))%>% #summarize across groups
  summarise(distance=sd(distance))%>% #summarize across groups
  summarise(distance=mean(distance)) #summarize across groups

spread.poc
```

 
2 - calculate distance between each time point centroids for each site (distance) 

```{r}
distance.poc<-poc.centroids%>%
  arrange(site_code)%>%
  gather(variable, value, -(timepoint:site_code)) %>%
  unite(temp, timepoint, variable) %>%
  spread(temp, value)%>%
  group_by(site_code)%>%
  mutate(tp1.2=sqrt((timepoint1_PC1.mean-timepoint2_PC1.mean)^2+(timepoint1_PC2.mean-timepoint2_PC2.mean)^2), #calculate distance between tp1 and tp2 centroids, do for each pair of time points
         tp2.3=sqrt((timepoint2_PC1.mean-timepoint3_PC1.mean)^2+(timepoint2_PC2.mean-timepoint3_PC2.mean)^2),
         tp3.4=sqrt((timepoint3_PC1.mean-timepoint4_PC1.mean)^2+(timepoint3_PC2.mean-timepoint4_PC2.mean)^2))
```

3 - divide distance by spread, generating a plasticity ratio for each site, higher ratio = more plasticity

```{r}
plasticity.poc.sym<-distance.poc%>%
  select(site_code, tp1.2, tp2.3, tp3.4)%>% #keep desired columns
  gather(key="comparison", value="distance_time", -site_code)%>% #gather and generate new rows to designate time comparisons
  mutate(ratio=distance_time/spread.poc$distance)%>%
  mutate(fraction="Symbiont")%>%
  mutate(species="Pocillopora")
plasticity.poc.sym
```

## Generate figure  

Bind all data frames together.  

```{r}
plasticity.pop<-rbind(plasticity.acr.holo, plasticity.por.holo, plasticity.poc.holo, plasticity.acr.sym, plasticity.poc.sym, plasticity.por.sym)
head(plasticity.pop)
#plasticity.acr.all, plasticity.poc.all, plasticity.por.all

#reorder site levels 
plasticity.pop$side_code<-as.factor(plasticity.pop$site_code)
plasticity.pop$site_code<-fct_relevel(plasticity.pop$site_code, "Mahana Low", "Hilton Medium", "Manava High")
```

Plot plasticity values with fill for fraction (all responses, holobiont, or symbiont), site on x axis in increasing nutrient exposure, and faceted by species. 

First, plot panel that shows fraction/species at each site. 
```{r}
figure1a<-plasticity.pop%>% 
    group_by(species, site_code, fraction)%>%
    summarise(mean=mean(ratio))%>%
    ggplot(aes(x = site_code, y = mean, fill=fraction, group=interaction(species, site_code))) +
    facet_wrap(~species)+
    geom_point(pch = 21, size=5, position = position_jitterdodge(0.5), color="black") + 
    scale_fill_manual(values = c("darkgray", "white"))+
    xlab("Site") + 
    ylab(expression(bold("Plasticity Score")))+
    theme_classic() + 
    #ylim(0.5,3)+
    theme(
      legend.position="right",
      legend.title=element_text(face="bold", size=14),
      legend.text=element_text(size=14),
      panel.border = element_rect(color = "black", fill = NA, size = 1),
      axis.title=element_text(face="bold", size=12),
      axis.text=element_text(size=10, color="black"), 
      strip.text.x=element_text(face="italic", size=14)
      ); figure1a
```

Second, plot panel that shows fraction/species by time point comparison.  
```{r}
figure1b<-plasticity.pop%>% 
    group_by(species, comparison, fraction)%>%
    summarise(mean=mean(ratio))%>%
    ggplot(aes(x = comparison, y = mean, fill=fraction, group=interaction(species, comparison))) +
    facet_wrap(~species)+
    geom_point(pch = 21, size=5, position = position_jitterdodge(0.5), color="black") + 
    scale_fill_manual(values = c("darkgray", "white"))+
    scale_x_discrete(labels=c("tp1.2" = "Jan-March", "tp2.3" = "March-Sept", "tp3.4" = "Sept-Nov"))+
    xlab("Time") + 
    ylab(expression(bold("Plasticity Score")))+
    theme_classic() + 
    #ylim(0.5,3)+
    theme(
      legend.position="right",
      legend.title=element_text(face="bold", size=14),
      legend.text=element_text(size=14),
      panel.border = element_rect(color = "black", fill = NA, size = 1),
      axis.title=element_text(face="bold", size=12),
      axis.text=element_text(size=10, color="black"), 
      strip.text.x=element_text(face="italic", size=14)
      ); figure1b
```

Export figure.  
```{r}
plasticity_grid<-plot_grid(figure1a, figure1b, ncol=1, nrow=2)

ggsave(filename="Figures/Plasiticity_Figure.png", plot=plasticity_grid, dpi=500, width=14, height=8, units="in")
```

# Colony - level analysis  

## All responses   

Generate centroid locations and spread for each colony as done in script 4_multivariate_analysis.Rmd. This analysis is completed at the level of the colony instead of the population level.  

```{r}
data_all<-master%>%
  select(colony_id_corr, timepoint, species, site_code, Host_AFDW.mg.cm2, Sym_AFDW.mg.cm2, Ratio_AFDW.mg.cm2, prot_mg.mgafdw, cells.mgAFDW, cre.umol.mgafdw, Am, AQY, Rd, calc.umol.mgAFDW.hr, Total_Chl, Total_Chl_cell)%>%
  filter(Host_AFDW.mg.cm2>0)%>%
  filter(Sym_AFDW.mg.cm2>0)%>%
  filter(Ratio_AFDW.mg.cm2>0)%>%
  filter(Sym_AFDW.mg.cm2<20)%>%
  filter(prot_mg.mgafdw<1.5)%>% #remove outliers
  rename(Host_Biomass=Host_AFDW.mg.cm2, Symbiont_Biomass=Sym_AFDW.mg.cm2, S_H_Biomass_Ratio=Ratio_AFDW.mg.cm2, Host_Protein=prot_mg.mgafdw, Symbiont_Density=cells.mgAFDW, Antiox_Capacity=cre.umol.mgafdw, Calc=calc.umol.mgAFDW.hr)

data_all<-data_all[complete.cases(data_all), ]

scaled_all<-prcomp(data_all[c(5:16)], scale=TRUE, center=TRUE) 

all_info<-data_all[c(1:4)]

all_data<-scaled_all%>%
  augment(all_info)%>%
  group_by(timepoint, site_code, species, colony_id_corr)%>%
  mutate(PC1.mean = mean(.fittedPC1),
         PC2.mean = mean(.fittedPC2))

all.centroids<-all_data %>% 
  select(timepoint, site_code, species, colony_id_corr, PC1.mean, PC2.mean)%>%
  group_by(timepoint, site_code, species, colony_id_corr)%>%
  summarise(PC1.mean = mean(PC1.mean),
         PC2.mean = mean(PC2.mean))
```

1 - calculate distance between all points and the centroid of all points for each colony (spread)

```{r}

#calculate mean centroid location
mean.centroid.all <- all.centroids%>%
  group_by(colony_id_corr)%>%
  summarise(x.mean = mean(PC1.mean), 
         y.mean = mean(PC2.mean)) 

#calculate average standard deviation of mean distance between mean centroid and location of each point using formula for distance between two points

all_data$x.mean<-mean.centroid.all$x.mean[match(all_data$colony_id_corr, mean.centroid.all$colony_id_corr)]
all_data$y.mean<-mean.centroid.all$y.mean[match(all_data$colony_id_corr, mean.centroid.all$colony_id_corr)]

#calculate spread as the square root of squared distances between mean PC location of each colony measurement and average PC location for each colony
all_data<-all_data%>%
  mutate(spread=sqrt((PC1.mean-x.mean)^2+(PC2.mean-y.mean)^2))

#calculate average spread for each colony
spread.all<-all_data%>%
  group_by(colony_id_corr)%>%
  summarise(spread.mean=mean(spread), spread.sd=sd(spread), n=length(spread))
```

2 - calculate distance between each time point centroid colony (distance)  

```{r}
distance.all<-all.centroids%>%
  arrange(timepoint)%>%
  gather(variable, value, -(timepoint:colony_id_corr)) %>%
  unite(temp, timepoint, variable) %>%
  spread(temp, value)%>%
  group_by(colony_id_corr)%>%
  mutate(tp1.2=sqrt((timepoint1_PC1.mean-timepoint2_PC1.mean)^2+(timepoint1_PC2.mean-timepoint2_PC2.mean)^2), #calculate distance between tp1 and tp2 centroids, do for each pair of time points
         tp2.3=sqrt((timepoint2_PC1.mean-timepoint3_PC1.mean)^2+(timepoint2_PC2.mean-timepoint3_PC2.mean)^2),
         tp3.4=sqrt((timepoint3_PC1.mean-timepoint4_PC1.mean)^2+(timepoint3_PC2.mean-timepoint4_PC2.mean)^2), 
         tp1.3=sqrt((timepoint1_PC1.mean-timepoint3_PC1.mean)^2+(timepoint1_PC2.mean-timepoint3_PC2.mean)^2), 
         tp1.4=sqrt((timepoint1_PC1.mean-timepoint4_PC1.mean)^2+(timepoint1_PC2.mean-timepoint4_PC2.mean)^2), 
         tp2.4=sqrt((timepoint2_PC1.mean-timepoint4_PC1.mean)^2+(timepoint2_PC2.mean-timepoint4_PC2.mean)^2))
```

3 - divide distance by spread for each colony, generating a plasticity score. The higher score = more distance in physiological trajectory relative to variability (spread).  

```{r}
#remove colonies that were only observed at one time point and therefore cannot be calculated due to no distance measurements 
plasticity.all<-left_join(distance.all, spread.all)%>%
  #select(site_code, colony_id_corr, species, tp1.2, tp2.3, tp3.4, tp1.3, tp1.4, tp2.4, spread.mean)%>% #keep desired columns
  select(site_code, colony_id_corr, species, tp1.2, tp2.3, tp3.4, spread.mean)%>% #keep desired columns
  relocate(spread.mean, .after=species)%>%
  filter(!spread.mean==0)%>% 
  mutate(distance.mean = mean(c_across(starts_with("tp")), na.rm = TRUE))%>%
  mutate(plasticity=distance.mean/spread.mean)
  
```

4 - average these scores across colony to generate a mean plasticity ratio for each species and site with std. error.  

Display mean plasticity scores by site:  
```{r}
all.plasticity.stats<-plasticity.all%>%
  filter(!is.na(plasticity))%>%
  group_by(site_code, species)%>%
  summarise(plasticity.mean=mean(plasticity, na.rm=TRUE), plasticity.sd=sd(plasticity, na.rm=TRUE), n=length(plasticity), plasticity.se=plasticity.sd/sqrt(n))%>%
  mutate(fraction="All Responses")
all.plasticity.stats
```


## Holobiont responses  

Generate centroid locations and spread for each colony as done in script 4_multivariate_analysis.Rmd. This analysis is completed at the level of the colony instead of the population level.  

Generate a list of symbiont and holobiont responses.  
```{r}
symbiont_responses<-c("cells.mgAFDW", "Sym_AFDW.mg.cm2", "Total_Chl", "Total_Chl_cell", "Am", "AQY", "Ratio_AFDW.mg.cm2") 
holobiont_responses<-c("cre.umol.mgafdw", "Host_AFDW.mg.cm2", "prot_mg.mgafdw", "Rd", "calc.umol.mgAFDW.hr")
```

```{r}
data_holo<-master%>%
  select(colony_id_corr, timepoint, species, site_code, all_of(holobiont_responses))%>%
  filter(Host_AFDW.mg.cm2>0)%>%
  #filter(Sym_AFDW.mg.cm2>0)%>%
  #filter(Ratio_AFDW.mg.cm2>0)%>%
  #filter(Sym_AFDW.mg.cm2<20)%>%
  filter(prot_mg.mgafdw<1.5)%>% #remove outliers
  rename(Host_Biomass=Host_AFDW.mg.cm2, Host_Protein=prot_mg.mgafdw, Antiox_Capacity=cre.umol.mgafdw, Calc=calc.umol.mgAFDW.hr)

data_holo<-data_holo[complete.cases(data_holo), ]

scaled_holo<-prcomp(data_holo[c(5:9)], scale=TRUE, center=TRUE) 

holo_info<-data_holo[c(1:4)]

holo_data<-scaled_holo%>%
  augment(holo_info)%>%
  group_by(timepoint, site_code, species, colony_id_corr)%>%
  mutate(PC1.mean = mean(.fittedPC1),
         PC2.mean = mean(.fittedPC2))

holo.centroids<-holo_data %>% 
  select(timepoint, site_code, species, colony_id_corr, PC1.mean, PC2.mean)%>%
  group_by(timepoint, site_code, species, colony_id_corr)%>%
  summarise(PC1.mean = mean(PC1.mean),
         PC2.mean = mean(PC2.mean))
```

1 - calculate distance between all points and the centroid of all points for each colony (spread)

```{r}

#calculate mean centroid location
mean.centroid.holo <- holo.centroids%>%
  group_by(colony_id_corr)%>%
  summarise(x.mean = mean(PC1.mean), 
         y.mean = mean(PC2.mean)) 

#calculate average standard deviation of mean distance between mean centroid and location of each point using formula for distance between two points

holo_data$x.mean<-mean.centroid.holo$x.mean[match(holo_data$colony_id_corr, mean.centroid.holo$colony_id_corr)]
holo_data$y.mean<-mean.centroid.holo$y.mean[match(holo_data$colony_id_corr, mean.centroid.holo$colony_id_corr)]

#calculate spread as the square root of squared distances between mean PC location of each colony measurement and average PC location for each colony
holo_data<-holo_data%>%
  mutate(spread=sqrt((PC1.mean-x.mean)^2+(PC2.mean-y.mean)^2))

#calculate average spread for each colony
spread.holo<-holo_data%>%
  group_by(colony_id_corr)%>%
  summarise(spread.mean=mean(spread), spread.sd=sd(spread), n=length(spread))
```

2 - calculate distance between each time point centroid colony (distance)  

```{r}
distance.holo<-holo.centroids%>%
  arrange(timepoint)%>%
  gather(variable, value, -(timepoint:colony_id_corr)) %>%
  unite(temp, timepoint, variable) %>%
  spread(temp, value)%>%
  group_by(colony_id_corr)%>%
  mutate(tp1.2=sqrt((timepoint1_PC1.mean-timepoint2_PC1.mean)^2+(timepoint1_PC2.mean-timepoint2_PC2.mean)^2), #calculate distance between tp1 and tp2 centroids, do for each pair of time points
         tp2.3=sqrt((timepoint2_PC1.mean-timepoint3_PC1.mean)^2+(timepoint2_PC2.mean-timepoint3_PC2.mean)^2),
         tp3.4=sqrt((timepoint3_PC1.mean-timepoint4_PC1.mean)^2+(timepoint3_PC2.mean-timepoint4_PC2.mean)^2), 
         tp1.3=sqrt((timepoint1_PC1.mean-timepoint3_PC1.mean)^2+(timepoint1_PC2.mean-timepoint3_PC2.mean)^2), 
         tp1.4=sqrt((timepoint1_PC1.mean-timepoint4_PC1.mean)^2+(timepoint1_PC2.mean-timepoint4_PC2.mean)^2), 
         tp2.4=sqrt((timepoint2_PC1.mean-timepoint4_PC1.mean)^2+(timepoint2_PC2.mean-timepoint4_PC2.mean)^2))
```

3 - divide distance by spread for each colony, generating a plasticity score. The higher score = more distance in physiological trajectory relative to variability (spread).  

```{r}
#remove colonies that were only observed at one time point and therefore cannot be calculated due to no distance measurements 
plasticity.holo<-left_join(distance.holo, spread.holo)%>%
  #select(site_code, colony_id_corr, species, tp1.2, tp2.3, tp3.4, tp1.3, tp1.4, tp2.4, spread.mean)%>% #keep desired columns
  select(site_code, colony_id_corr, species, tp1.2, tp2.3, tp3.4, spread.mean)%>% #keep desired columns
  relocate(spread.mean, .after=species)%>%
  filter(!spread.mean==0)%>% 
  mutate(distance.mean = mean(c_across(starts_with("tp")), na.rm = TRUE))%>%
  mutate(plasticity=distance.mean/spread.mean)
  
```

4 - average these scores across colony to generate a mean plasticity ratio for each species and site with std. error.  

Display mean plasticity scores by site:  
```{r}
holo.plasticity.stats<-plasticity.holo%>%
  filter(!is.na(plasticity))%>%
  group_by(site_code, species)%>%
  summarise(plasticity.mean=mean(plasticity, na.rm=TRUE), plasticity.sd=sd(plasticity, na.rm=TRUE), n=length(plasticity), plasticity.se=plasticity.sd/sqrt(n))%>%
  mutate(fraction="Holobiont")
holo.plasticity.stats
```

## Symbiont responses  

Generate centroid locations and spread for each colony as done in script 4_multivariate_analysis.Rmd. This analysis is completed at the level of the colony instead of the population level.  

```{r}
data_sym<-master%>%
  select(colony_id_corr, timepoint, species, site_code, all_of(symbiont_responses))%>%
  #filter(Host_AFDW.mg.cm2>0)%>%
  filter(Sym_AFDW.mg.cm2>0)%>%
  filter(Ratio_AFDW.mg.cm2>0)%>%
  filter(Sym_AFDW.mg.cm2<20)%>%
  #filter(prot_mg.mgafdw<1.5)%>% #remove outliers
  rename(Symbiont_Biomass=Sym_AFDW.mg.cm2, S_H_Biomass_Ratio=Ratio_AFDW.mg.cm2, Symbiont_Density=cells.mgAFDW)

data_sym<-data_sym[complete.cases(data_sym), ]

scaled_sym<-prcomp(data_sym[c(5:11)], scale=TRUE, center=TRUE) 

sym_info<-data_sym[c(1:4)]

sym_data<-scaled_sym%>%
  augment(sym_info)%>%
  group_by(timepoint, site_code, species, colony_id_corr)%>%
  mutate(PC1.mean = mean(.fittedPC1),
         PC2.mean = mean(.fittedPC2))

sym.centroids<-sym_data %>% 
  select(timepoint, site_code, species, colony_id_corr, PC1.mean, PC2.mean)%>%
  group_by(timepoint, site_code, species, colony_id_corr)%>%
  summarise(PC1.mean = mean(PC1.mean),
         PC2.mean = mean(PC2.mean))
```

1 - calculate distance between all points and the centroid of all points for each colony (spread)

```{r}

#calculate mean centroid location
mean.centroid.sym <- sym.centroids%>%
  group_by(colony_id_corr)%>%
  summarise(x.mean = mean(PC1.mean), 
         y.mean = mean(PC2.mean)) 

#calculate average standard deviation of mean distance between mean centroid and location of each point using formula for distance between two points

sym_data$x.mean<-mean.centroid.sym$x.mean[match(sym_data$colony_id_corr, mean.centroid.sym$colony_id_corr)]
sym_data$y.mean<-mean.centroid.sym$y.mean[match(sym_data$colony_id_corr, mean.centroid.sym$colony_id_corr)]

#calculate spread as the square root of squared distances between mean PC location of each colony measurement and average PC location for each colony
sym_data<-sym_data%>%
  mutate(spread=sqrt((PC1.mean-x.mean)^2+(PC2.mean-y.mean)^2))

#calculate average spread for each colony
spread.sym<-sym_data%>%
  group_by(colony_id_corr)%>%
  summarise(spread.mean=mean(spread), spread.sd=sd(spread), n=length(spread))
```

2 - calculate distance between each time point centroid colony (distance)  

```{r}
distance.sym<-sym.centroids%>%
  arrange(timepoint)%>%
  gather(variable, value, -(timepoint:colony_id_corr)) %>%
  unite(temp, timepoint, variable) %>%
  spread(temp, value)%>%
  group_by(colony_id_corr)%>%
  mutate(tp1.2=sqrt((timepoint1_PC1.mean-timepoint2_PC1.mean)^2+(timepoint1_PC2.mean-timepoint2_PC2.mean)^2), #calculate distance between tp1 and tp2 centroids, do for each pair of time points
         tp2.3=sqrt((timepoint2_PC1.mean-timepoint3_PC1.mean)^2+(timepoint2_PC2.mean-timepoint3_PC2.mean)^2),
         tp3.4=sqrt((timepoint3_PC1.mean-timepoint4_PC1.mean)^2+(timepoint3_PC2.mean-timepoint4_PC2.mean)^2), 
         tp1.3=sqrt((timepoint1_PC1.mean-timepoint3_PC1.mean)^2+(timepoint1_PC2.mean-timepoint3_PC2.mean)^2), 
         tp1.4=sqrt((timepoint1_PC1.mean-timepoint4_PC1.mean)^2+(timepoint1_PC2.mean-timepoint4_PC2.mean)^2), 
         tp2.4=sqrt((timepoint2_PC1.mean-timepoint4_PC1.mean)^2+(timepoint2_PC2.mean-timepoint4_PC2.mean)^2))
```

3 - divide distance by spread for each colony, generating a plasticity score. The higher score = more distance in physiological trajectory relative to variability (spread).  

```{r}
#remove colonies that were only observed at one time point and therefore cannot be calculated due to no distance measurements 
plasticity.sym<-left_join(distance.sym, spread.sym)%>%
  #select(site_code, colony_id_corr, species, tp1.2, tp2.3, tp3.4, tp1.3, tp1.4, tp2.4, spread.mean)%>% #keep desired columns
  select(site_code, colony_id_corr, species, tp1.2, tp2.3, tp3.4, spread.mean)%>% #keep desired columns
  relocate(spread.mean, .after=species)%>%
  filter(!spread.mean==0)%>% 
  mutate(distance.mean = mean(c_across(starts_with("tp")), na.rm = TRUE))%>%
  mutate(plasticity=distance.mean/spread.mean)
  
```

4 - average these scores across colony to generate a mean plasticity ratio for each species and site with std. error.  

Display mean plasticity scores by site:  
```{r}
sym.plasticity.stats<-plasticity.sym%>%
  filter(!is.na(plasticity))%>%
  group_by(site_code, species)%>%
  summarise(plasticity.mean=mean(plasticity, na.rm=TRUE), plasticity.sd=sd(plasticity, na.rm=TRUE), n=length(plasticity), plasticity.se=plasticity.sd/sqrt(n))%>%
  mutate(fraction="Symbiont")
sym.plasticity.stats
```

## Generate figure 

Our data frames of interest are: 

`all.plasticity.stats`
`holo.plasticity.stats`
`symb.plasticity.stats` 

Join data frames.  

```{r}
df <- rbind(all.plasticity.stats, holo.plasticity.stats, sym.plasticity.stats)
```

Generate figure faceted by fraction with site on x axis and species in color.  

```{r}
figure2<-df%>% 
    group_by(species, site_code, fraction)%>%
    summarise(mean=mean(plasticity.mean), se=mean(plasticity.se))%>%
    ggplot(aes(x = site_code, y = mean, fill=species, group=interaction(species, site_code))) +
    facet_wrap(~fraction)+
    geom_point(pch = 21, size=5, position = position_dodge(0.15)) + 
    geom_errorbar(aes(ymin=mean-se, ymax=mean+se, group=interaction(species, site_code)), width=0, color="black", position=position_dodge(0.15))+
    scale_fill_manual(values = c("darkgray", "orange", "purple"))+
    xlab("Site") + 
    ylab(expression(bold("Plasticity Score (Distance / Spread)")))+
    theme_classic() + 
    ylim(0.5,3)+
    theme(
      legend.position="right",
      legend.title=element_text(face="bold", size=14),
      legend.text=element_text(size=14),
      axis.title=element_text(face="bold", size=12),
      axis.text=element_text(size=10, color="black"), 
      strip.text.x=element_text(face="italic", size=14)
      ); figure2
```

