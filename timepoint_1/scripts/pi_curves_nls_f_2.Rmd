---
title: "pi_curves_nls"
author: "Ariana S Huffmyer"
date: "3/18/2021"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, message = FALSE, warning = FALSE)
```

```{r load_packages}
## install packages if you dont already have them in your library
if ("devtools" %in% rownames(installed.packages()) == 'FALSE') install.packages('devtools') 
if ("segmented" %in% rownames(installed.packages()) == 'FALSE') install.packages('segmented') 
if ("plotrix" %in% rownames(installed.packages()) == 'FALSE') install.packages('plotrix') 
if ("gridExtra" %in% rownames(installed.packages()) == 'FALSE') install.packages('gridExtra') 
if ("LoLinR" %in% rownames(installed.packages()) == 'FALSE') install_github('colin-olito/LoLinR') 
if ("lubridate" %in% rownames(installed.packages()) == 'FALSE') install.packages('lubridate') 
if ("chron" %in% rownames(installed.packages()) == 'FALSE') install.packages('chron') 
if ("plyr" %in% rownames(installed.packages()) == 'FALSE') install.packages('plyr') 
if ("dplyr" %in% rownames(installed.packages()) == 'FALSE') install.packages('dplyr') 
if ("phytotools" %in% rownames(installed.packages()) == 'FALSE') install.packages('phytotools') 
if ("tidyverse" %in% rownames(installed.packages()) == 'FALSE') install.packages('tidyverse') 
if ("broom" %in% rownames(installed.packages()) == 'FALSE') install.packages('broom') 

#Read in required libraries

library("devtools")
library("ggplot2")
library("segmented")
library("plotrix")
library("gridExtra")
library("LoLinR")
library("lubridate")
library("chron")
library('plyr')
library('dplyr')
library('phytotools')
library("tidyverse")
library("broom")
```

# Import data
```{r import_data}
Data <- read.csv(file = '/home/spc/timeseries/timepoint_1/output/1_pi_curve_rates.csv')
#Data <- Data[1:40,]
```


# Define data  

```{r}
#PAR <- as.numeric(Data$Light_Value)
#Pc <- as.numeric(Data$micromol.cm2.h)
#plot(PAR,Pc,xlab="", ylab="", xlim=c(0,max(PAR)), ylim=c(-2, 2), cex.lab=0.8,cex.axis=0.8,cex=1, main="", adj = 0.05) #set plot info
#mtext(expression("Irradiance ("*mu*"mol photons "*m^-2*s^-1*")"),side=1,line=3.3,cex=1) #add labels
#mtext(expression(Rate*" ("*mu*"mol "*O[2]*" "*cm^-2*h^-1*")"),side=2,line=2,cex=1) #add labels
```

# Define PI curve function as a nonlinear Least Squares regression of a quadratic fit, test nls fit

```{r}
#Aquatic Photosynthesis, Falkowski 
#Pmax = max photosynthesis (AKA Am from Bayesian script)
#alpha = quantum yeild (AKA AQY from Bayesian script)
#I/E = irradiance (AKA PAR from Bayesian script)
#Rd = dark respiration 

#df <- data.frame(PAR, Pc)
#curve.nls <- nls(Pc ~ (Am*((AQY*PAR)/(sqrt(Am^2 + (AQY*PAR)^2)))-Rd), data=df, start=list(Am=1, AQY=0.05, Rd=.2))
#my.fit <- summary(curve.nls)
#my.fit
```

Run models - NOTE: Need to look at starting values, currently getting an error for singular gradient matrix
```{r}
#specify data
Data$PAR <- as.numeric(Data$Light_Value)
Data$Pc <- as.numeric(Data$micromol.cm2.h)
```

THIS ONE WORKS (fixed initial values): 

```{r}
#use tidy to group by colony, then map data using nls curve and pull out coeffients to generate a new data frame

#Script version 1
#nls_data <- Data %>% 
  #filter(colony_id==c("ACR-140"))%>%
  #group_by(colony_id) %>% #group by colony
  #nest(-colony_id) %>% #nest data by colony
  #mutate(
   # fit = map(data, ~ nls(Pc ~ (Am*((AQY*PAR)/(sqrt(Am^2 + (AQY*PAR)^2)))-Rd), data=.)), #fit nls curve
  #  tidied = map(fit, tidy), #pull out coefficients from model
 # ) %>% 
 # unnest(tidied) %>% #unnest data
 # select(colony_id, term, estimate) %>% #keep columns we want
 # spread(term, estimate) #spread columns by coefficient for each colony

#Script version 2 - adjusted starting values to reflect values we are getting from models on single colony (when filtering)
nls_data <- Data %>% 
   #filter(colony_id==c("ACR-140"))%>%
   group_by(colony_id) %>%
   nest(-colony_id) %>%
   mutate(model1 = map(data, ~ 
                         nls(Pc ~ (Am*((AQY*PAR)/(sqrt(Am^2 + (AQY*PAR)^2)))-Rd), data=., start=list(Am=0.7,  AQY=0.001, Rd=.4)) %>%
                              tidy %>%
                              dplyr::select(term, estimate) %>% 
                              spread(term, estimate))) %>%
  unnest(model1) %>%
  unnest(data) %>%
  group_by(colony_id)%>%
  summarise(Am=mean(Am), AQY=mean(AQY), Rd=mean(Rd))%>%
  mutate(timepoint="timepoint1")%>%
  write_csv(., "/home/spc/timeseries/timepoint_1/output/1_pi_curve_pars_NLS_fixed_inis.csv")

#start=list(Am=(max(Pc)-min(Pc)),AQY=0.001,Rd=-min(Pc))
#start=list(Am=0.7,  AQY=0.001, Rd=.4))

```
Flexible data points - this one seems to work
```{r}
#Script version 1b - adjusted starting values to reflect values we are getting from models on single colony (when filtering)
nls_data <- Data %>% 
   #filter(colony_id==c("ACR-140"))%>%
   group_by(colony_id) %>%
   nest(-colony_id) %>%
   mutate(model1 = map(data, ~ 
                         nls(Pc ~ (Am*((AQY*PAR)/(sqrt(Am^2 + (AQY*PAR)^2)))-Rd), data=., start=list(Am=(max(.$Pc)-min(.$Pc)),  AQY=0.001, Rd=-min(.$Pc))) %>%
                              tidy %>%
                              dplyr::select(term, estimate) %>% 
                              spread(term, estimate))) %>%
  unnest(model1) %>%
  unnest(data) %>%
  group_by(colony_id)%>%
  summarise(Am=mean(Am), AQY=mean(AQY), Rd=mean(Rd))%>%
  mutate(timepoint="timepoint1")%>%
  write_csv(., "/home/spc/timeseries/timepoint_1/output/1_pi_curve_pars_NLS-data-inis.csv")

#start=list(Am=(max(Pc)-min(Pc)),AQY=0.001,Rd=-min(Pc))
#start=list(Am=0.7,  AQY=0.001, Rd=.4))

```
```

THIS ONE DOESN'T WORK (changed initial values to reference data + nls control): 

```{r}

nls_data <- Data %>% 
   #filter(colony_id==c("ACR-140"))%>%
   group_by(colony_id) %>%
   nest(-colony_id) %>%
   mutate(model1 = map(data, ~ 
                         nls(Pc ~ (Am*((AQY*PAR)/(sqrt(Am^2 + (AQY*PAR)^2)))-Rd), data=., start=list(Am=(max(.$Pc)-min(.$Pc)),AQY=0.001,Rd=-min(.$Pc), control = nls.control(tol = 1e-05, minFactor = 1/1000))) %>%
                              tidy %>%
                              dplyr::select(term, estimate) %>% 
                              spread(term, estimate))) %>%
  unnest(model1) %>%
  unnest(data) %>%
  group_by(colony_id)%>%
  summarise(Am=mean(Am), AQY=mean(AQY), Rd=mean(Rd))%>%
  mutate(timepoint="timepoint1")%>%
  write_csv(., "output/1_pi_curve_pars_NLS.csv")

```




Plot curve over data points.  
```{r}
augmented <- Data %>% 
  nest(-colony_id) %>% 
  mutate(
    fit = map(data, ~ nls(Pc ~ (Am*((AQY*PAR)/(sqrt(Am^2 + (AQY*PAR)^2)))-Rd), data=., start=list(Am=0.7,  AQY=0.001, Rd=.4))),
    augmented = map(fit, augment),
  ) %>% 
  unnest(augmented)


#all colonies together
augmented %>%
  group_by(colony_id)%>%
  qplot(PAR, Pc, data = ., geom = 'point', colour = colony_id) +
  geom_line(aes(y=.fitted))+
  theme(legend.position="none")


#view individual plots
by(augmented,augmented$colony_id, function(i) {
  ggplot(i) +
          geom_point(aes(PAR, Pc, group=colony_id)) + 
          geom_line(aes(y=.fitted, x=PAR)) + 
          theme_classic()+
          labs(x = expression(paste('PAR (', mu, "mol photons m"^-2, 's'^-1,")")),
               y = expression(paste('Photosynthetic rate (', mu, "mol cm"^-2, 'h'^-1,")")),
               title = paste0("1_", augmented$colony_id))
})

#NEED TO FIND A WAY TO SAVE INDIVIDUALS 
```










